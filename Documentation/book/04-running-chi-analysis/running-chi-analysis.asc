== Running the chi analysis

The chi analysis, and a host of other analyses, are run using the *chi_mapping_tool.exe* program. If you followed the instructions in the section <<Getting the software>> you will already have this program compiled. 

The program *chi_mapping_tool.exe* runs with two inputs when you call the program:

1. The path to the parameter file. This **MUST** inculde the trailing slash (i.e., `/LSDTopoTools/Topographic_projects/Test_data` is incorrect whereas `/LSDTopoTools/Topographic_projects/Test_data/` is correct).
2. The name of the parameter file.

So if the parameter file is located at `/LSDTopoTools/Topographic_projects/Test_data` and it is called `test_chi_map.param`, you run the program with:

[source,console]
-----
$ ./chi_mapping_tool.exe /LSDTopoTools/Topographic_projects/Test_data test_chi_map.param 
-----

As we will see momentarily, the data and the parameter file can be in different locations, although in general it might be sensible to place the parameter file in the sample directory as the data.

The code is run using a parameter file, within which users can set the data they want to print to file. Regardless of which data they choose to print to file, a file will be printed with the extension `_Input.param` which prints out all the parameters used in the analysis (including the default parameters). This file can be used to verify if the correct parameters have been used in the analysis. 

=== The parameter file

The parameter file has keywords followed by a value. The format of this file is similar to the files used in the `LSDTT_analysis_from_paramfile` program, which you can read about in the section <<Running your first analysis>>.

NOTE: The parameter file has a specific format, but the filename can be anything you want. We tend to use the extensions `.param` and `.driver` for these files, but you could use the extension `.MyDogSpot` if that tickled your fancy.

The parameter file has keywords followed by the `:` character. After that there is a space and the value. 

.Chi mapping parameter file format
************************************************
. Lines beginning with `#` are comments.
. Keywords or phrases are followed by a colon (`:`).
. The order of the keywords do not matter.
. Keywords are not sensitive, but must match expected keywords.
. If a keyword is not found, a default value is assigned.
************************************************


=== Parameter file options

Below are options for the parameter files. Note that all DEMs must be in ENVI `bil` format (**DO NOT** use ArcMap's bil format: these are two different things. See the section <<What data does LSDTopoToolbox take?>> if you want more details). 
The reason we use `bil` format is because it retains georeferencing which is essential to our file output since many of the files output to `csv` format with latitude and longitude as coordinates. 


[cols="1,1,2", options="header"]
.File input and output options. **These do not have defaults and MUST be declared**.
|===
|Keyword
|Input type
|Description

|write path
|string
|The path to which data is written. **The code will NOT create a path: you need to make the write path before you start running the program.**

|read path
|string
|The path from which data is read.

|write fname
|string
|The prefix of rasters to be written *without extension*.
For example if this is `Test` and you have selected `bil` format then a fill operation will result in a file called `Test_Fill.bil`.

|read fname
|string
|The filename of the raster to be read without extension. For example if the raster is `MyRaster.bil`, read fname will be `MyRaster`.


|channel heads fname
|string
|The filename of a channel heads file. You can import channel heads. If this is set to `NULL` then the channels will be calculated using a pixel threshold. 

|===



[cols="1,1,1,2", options="header"]
.DEM preprocessing. These just help you clean data and perform very basic operations.
|===
|Keyword
|Input type
|Default value
|Description


|minimum_elevation
|float
|0
|If you have the `remove_seas` keyword set to true, the program will change any elevation node below this value to NoData.

|maximum_elevation
|float
|30000
|If you have the `remove_seas` keyword set to true, the program will change any elevation node above this value to NoData.

|remove_seas
|bool
|false
|If true, this changes extreme value in the elevation to NoData.

|min_slope_for_fill
|float
|0.001
|The minimum slope between pixels for use in the fill function. 

|raster_is_filled
|bool
|false
|If true, the code assumes the raster is already filled and doesn't perform the filling routine. This should save some time in computation, but make sure the raster really is filled or else you will get segmentation faults!

|only_check_parameters
|bool
|false
|If true, this checks parameter values but doesn't run any analyses. Mainly used to see if raster files exist. 

|===


[cols="1,1,1,3", options="header"]
.Options for determining which channels and basins to analyse, including settings for the fill function.
|===
|Keyword
|Input type
|Default value
|Description


|threshold_contributing_pixels
|int
|1000
|The number of pixels required to generate a channel (i.e., the source threshold).

|minimum_basin_size_pixels
|int
|1000
|The minimum number of pixels in a basin for it to be retained. This operation works on the baselevel basins: subbasins within a large basin are retained. 

|test_drainage_boundaries
|bool (true or 1 will work)
|false
|A boolean that, if set to true, will eliminate basins with pixels drainage from the edge. This is to get rid of basins that may be truncated by the edge of the DEM (and thus will have incorrect chi values). 

|only_take_largest_basin
|bool (true or 1 will work) 
|true
|If this is true, a chi map is created based only upon the largest basin in the raster. 

|===




[cols="1,1,1,2", options="header"]
.Basic printing operations. For simple rasters and network data that doesn't require chi analysis.
|===
|Keyword
|Input type
|Default value
|Description

|convert_csv_to_geojson
|bool
|false
|If true, this converts any csv file (except for slope-area data) to geojson format. This format takes up much more space than csv (file sizes can be 10x larger) but is georeferenced and can be loaded directly into a GIS. Also useful for webmapping. It assumes your raster is in UTM coordinates, and prints points with latitude and longitude in WGS84. 


|print_stream_order_raster
|bool
|false
|If true, prints the stream order raster (but printing this to csv is more efficient, use `print_channels_to_csv`).


|print_channels_to_csv
|bool
|false
|Prints the channel network to a csv file. Includes stream order and other useful information. Much more memory efficient than printing the whole raster. 

|print_junction_index_raster
|bool
|false
|If true, prints the junction index raster (but printing this to csv is more efficient, use `print_junctions_to_csv`).

|print_junctions_to_csv
|bool
|false
|Prints the junction indices to a csv file. Much more memory efficient than printing the whole raster. 

|print_fill_raster
|bool
|false
|If true, prints the fill raster.

|print_DrainageArea_raster
|bool
|false
|If true, prints the drainage area raster (units are m^2^).

|write hillshade
|bool
|false
|If true, prints the hillshade raster. The format of this is stupidly different from other printing calls for a stupid inheritance reason. Try to ignore. Most GIS routines have a hillshading options but for some reason they look crappier than our in-house hillshading. I'm not sure why but if you want a hillshade I recommend using this function. 
|===







[cols="1,1,1,2", options="header"]
.Parameters for calculating the chi coordinate.
|===
|Keyword
|Input type
|Default value
|Description

|A_0
|float
|1
|The *A~0~* parameter (which nondimensionalises area) for chi analysis. This is in m^2^. Note that when *A_0* = 1 then the slope in chi space is the same as the channel steepness index (often denoted by *k~s~*). 
|m_over_n
|float
|0.5
|The *m/n* parameter (sometimes known as the concavity index) for calculating chi. Note that if you do any _m/n_ analysis (either `calculate_MLE_collinearity` or `print_profiles_fxn_movern_csv`) this _m/n_ value will be replaced.


|threshold_pixels_for_chi
|int
|0
|For most calculations in the *chi_mapping_tool* chi is calculated everywhere, but for some printing operations, such as printing of basic chi maps (`print_simple_chi_map_with_basins_to_csv`, `print_chi_coordinate_raster`, `print_simple_chi_map_to_csv`) you don't want chi everywhere (this is especially true when writing a simple csv file) so we have this parameter that sets chi to NoData below these threshold contributing pixels. If this is greater than `threshold_contributing_pixels` it will default to `threshold_contributing_pixels`.   

|===

[cols="1,1,1,2", options="header"]
.Parameters for trying to constrain the _m/n_ ratio, including slope-area analysis.
|===
|Keyword
|Input type
|Default value
|Description

|start_movern
|float
|0.1
|In several of the _m/n_ testing functions, the program starts at this _m/n_ value and then iterates through a number of increasing _m/n_ values, calculating the goodness of fit to each one.

|delta_movern
|float
|0.1
|In several of the _m/n_ testing functions, the program increments _m/n_ by this value.

|n_movern
|int
|8
|In several of the _m/n_ testing functions, the program increments _m/n_ this number of times. 

|SA_vertical_interval
|float
|20
|This parameter is used for slope-area analysis. Each channel is traced downslope. A slope (or gradient) is calculated by dividing the fall in the channel elevation over the flow distance; the program aims to calculate the slope at as near to a fixed vertical interval as possible following advice of Wobus et al 2006.

|log_A_bin_width
|float
|0.1
|This is for slope-area analysis. The raw slope-area data is always a horrendous mess. To get something that is remotely sensible you must bin the data. We bin the data in bins of the logarithm of the Area in metres^2. This is the log bin width.

|print_slope_area_data
|bool
|false
|This prints the slope-area analysis to a csv file. It includes the raw data and binned data. It is organised by both source and basin so you analyise different channels. See the section on outputs for full details. 

|===




[cols="1,1,1,2", options="header"]
.Parameters for calculating the segments of similar chi slope (stem:[M_{\chi}]). More details on the use of these parameters can be found in http://onlinelibrary.wiley.com/doi/10.1002/2013JF002981/abstract[Mudd et al., JGR-ES 2014].
|===
|Keyword
|Input type
|Default value
|Description

|n_iterations
|int
|20
|The number of iterations of random sampling of the data to construct segments. The sampling probability of individual nodes is determined by the skip parameter. Note that if you want to get a deterministic sampling of the segments you need to set this to 1 and set `skip` to 0. If you are using Monte Carlo sampling you should set this to at least 20 (but probably not more than 100).

|target_nodes
|int
|80
|The number of nodes in a segment finding routine. Channels are broken into subdomains of around this length and then segmenting occurs on these subdomains. This limit is required because of the computational expense of segmentation, which goes as the factorial (!!!) of the number of nodes. Select between 80-120. A higher number here will take *much* longer to compute. 

|minimum_segment_length
|int
|10
|The minimum length of a segment in sampled data nodes. The actual length is approximately this parameter times (1+skip). Note that the computational time required goes nonlinearly up the smaller this number. Note that this sets the shortest knickzone you can detect, although the algorithm can detect waterfalls where there is a jump between segments.  It should be between 6-20. 

|skip
|int
|2
|During Monte Carlo sampling of the channel network, nodes are sampled by skipping nodes after a sampled node. The skip value is the mean number of skipped nodes after each sampled node. For example, if skip = 1, on average every other node will be sampled. Skip of 0 means every node is sampled (in which case the n_iterations should be set to 1, because there will be no variation in the fit between iterations). If you want Monte Carlo sampling, set between 1 and 4. 

|sigma
|float
|10.0
|This represents the variability in elevation data (if the DEM has elevation in metres, then this parameter will be in metres). It should include both uncertainty in the elevation data as well as the geomorphic variability: the size of roughness elements, steps, boulders etc in the channel that may lead to a channel profile diverging from a smooth long profile. That is, it is not simply a function of the uncertainty of the DEM, but also a function of topographic roughness so will be greater than the DEM uncertainty. 

|basic_Mchi_regression_nodes
|int
|11
|This works with the basic chi map: segments are not calculated. Instead, a moving window, with a length set by this parameter, is moved over the channel nodes to calculate the chi slope. This method is very similar to methods used to calculate normalised channel steepness (_k~sn~_).

|n_nodes_to_visit
|int
|10
|The chi map starts with the longest channel in each basin and then works in tributaries in sequence. This parameter determines how many nodes onto a receiver channel you want to go when calculating the chi slope at the bottom of a tributary. 

|===

[cols="1,3", options="header"]
.Keywords for setting which analyses to be preformed and which files to print. **These are all booleans!** **Defaults are all false so these parameters must be set to true to perform analyses and print to file. 
|===
|Input type
|Description

|print_stream_order_raster
|If true, prints a raster of the stream orders. 

|print_junction_index_raster
|If true, prints a raster with the junction indices.

|print_fill_raster
|If true, prints a filled raster

|print DrainageArea_raster
|If true, prints a raster of the drainage area in m^2^.

|print_chi_coordinate_raster
|If true, prints a raster with the chi coordinate (in m). Note that if you want to control the size of the data symbols in a visualisation, you should select the `print_simple_chi_map_to_csv` option. 

|print_simple_chi_map_to_csv
|If true, prints a csv file with latitude, longitude and the chi coordinate. Can be converted to a shapefile or GeoJSON with our python mapping scripts. This options gives more flexibility in visualisation than the raster, since in the raster data points will only render as one pixel.

|print_simple_chi_map_to_csv
|If true, prints a csv file with latitude, longitude and the chi coordinate. Can be converted to a shapefile or GeoJSON with our python mapping scripts. This options gives more flexibility in visualisation than the raster, since in the raster data points will only render as one pixel.

|print_segmented_M_chi_map_to_csv
|If true, prints a csv file with latitude, longitude and a host of chi information including the chi slope, chi intercept, drainage area, chi coordinate and other features of the drainage network. The stem:[M_{\chi}] values are calculated with the segmentation algorithm of http://onlinelibrary.wiley.com/doi/10.1002/2013JF002981/abstract[Mudd et al. 2014].

|print_basic_M_chi_map_to_csv
|If true, prints a csv file with latitude, longitude and a host of chi information including the chi slope, chi intercept, drainage area, chi coordinate and other features of the drainage network. The stem:[M_{\chi}] values are calculated with a rudimentary smoothing window that has a size determined by the parameter `basic_Mchi_regression_nodes`.

|===



[cols="1,1,1,3", options="header"]
.Parameters for dealing with precipitation and discharge. These allow the user to drive chi with discharge rather than drainage area. It is somewhat rudimentary at the moment in that it  assumes the rainfall rate in length per time is translated into some constant discharge. 
|===
|Keyword
|Input type
|Default value
|Description

|precipitation_fname
|string
|NULL
|This is the name (without path or extension) of the precipitation file. There is not much error checking with this file! You *MUST* pass a file that is the same size as the topography raster!

|use_precipitation_raster_for_chi
|bool
|false
|When true, the program will use precipitation to generate a discharge raster and this will be used to calculate chi, rather than drainage area. 

|===


==== Example parameter file

Below is an example parameter file. This file is included in the repository along with the driver functions. 
[source,paramfile]
----
# Parameters for performing chi analysis
# Comments are preceeded by the hash symbol
# Documentation can be found here: 
# http://lsdtopotools.github.io/LSDTT_book/#_chi_analysis_part_3_getting_chi_gradients_for_the_entire_landscape

# These are parameters for the file i/o
# IMPORTANT: You MUST make the write directory: the code will not work if it doens't exist. 
read path: /LSDTopoTools/Topographic_projects/Test_data
write path: /LSDTopoTools/Topographic_projects/Test_data
read fname: Mandakini
channel heads fname: NULL

# Parameter for filling the DEM
min_slope_for_fill: 0.0001

# Parameters for selecting channels and basins

threshold_contributing_pixels: 200000
minimum_basin_size_pixels: 50000
test_drainage_boundaries: false

# Parameters for chi analysis
A_0: 1000
m_over_n: 0.45
threshold_pixels_for_chi: 20000

n_iterations: 20
target_nodes: 80
minimum_segment_length: 10
sigma: 10.0
skip: 2

# The data that you want printed to file
only_check_parameters: true
print_stream_order_raster: false
print_DrainageArea_raster: false
print_segmented_M_chi_map_to_csv: true
----

==== Output data formats

Data is written to either rasters or csv files. The rasters are all in `bil` format, which you can read about in the section: <<What data does LSDTopoToolbox take?>>

The **csv** files are comma separated value files which can be read by spreadsheets and GIS software. 
These files all have labeled columns so their contents can be easily views. 
All of the files contain **latitude** and **longitude** columns. These columns are projected into the **WGS84** coordinate system for ease of plotting in GIS software. 

===== Viewing data and converting to GIS ready formats

If the user has opted to print data in `csv` format, they can use our visualisation tools to convert the data into GIS-ready formats. 

Users should first clone the https://github.com/LSDtopotools/LSDMappingTools[mapping tools respoitory]:

[source,console]
----
$ git clone https://github.com/LSDtopotools/LSDMappingTools.git
----

In this repository the user needs to get a helping script called `LSDOSystemTools.py`. You can fetch this script using the `wget` tool:

[source,console]
----
$ wget https://github.com/LSDtopotools/LSDAutomation/raw/master/LSDOSystemTools.py
----

The user can then run the script `TestMappingToolsPoint.py`, activating the `TestMappingToolsLassoCSV` function:

[source,python]
----
if __name__ == "__main__":
    TestMappingToolsLassoCSV()
----

and changing the target directory to the directory storing the csv files:

[source,python]
----
def TestMappingToolsLassoCSV(): 
    DataDirectory = "C://VagrantBoxes//LSDTopoTools//Topographic_projects//Test_data//"
    LSDP.ConvertAllCSVToGeoJSON(DataDirectory)
----
Note that this is if your run the python script within windows. If you run it within your vagrant Linux machine the directory would be:

[source,python]
----
def TestMappingToolsLassoCSV(): 
    DataDirectory = "/LSDTopoTools/Topographic_projects/Test_data/"
    LSDP.ConvertAllCSVToGeoJSON(DataDirectory)
----


You can convert all `csv` files into either shapefiles or GeoJSON files. 

[source,python]
----
    LSDP.ConvertAllCSVToGeoJSON(DataDirectory)
    LSDP.ConvertAllCSVToShapefile(DataDirectory)
----

These files can then be read by your favourite GIS. 

